package main

//1.最常见的指针逃逸,因为函数创建的对象返回了其引用,因此不能随着栈回收而被销毁,因此会逃逸到堆上

//2.动态类型逃逸
//如Println时该变量作为实参传递给 fmt.Println()，但是因为 fmt.Println() 的参数类型定义为 interface{}，因此也发生了逃逸。

//3.栈空间不足 ulmit -a查看机器对栈空间的限制(一般时8M),所以在深度递归的函数中非常容易出现栈溢出
//当切片大小不确定或太大时,会逃逸到堆上

//4.闭包
/* 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。 */

//在实际工作中就需要衡量内存逃逸带来的性能影响
//如,传值还是传指针?传指针会导致变量分配到堆上,增加GC压力,尤其是在对象频繁创建的情况下

//指针意味着分享,传值代表着拷贝
